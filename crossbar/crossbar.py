import xlrd

class Crossbar(object):

    def __init__(self, excelFileName, sheetName):
        self.portDictByIndex = {}
        self.funcDictByRow = {}
        self.crossCoList = []
        self._processExcelFile(excelFileName, sheetName)


    def _processExcelFile(self, excelFileName, sheetName):
        self.book = xlrd.open_workbook(excelFileName)
        self.sheet = self.book.sheet_by_name(sheetName)

        if self.sheet.row_values(0)[0] == "Port":
            port_num = len(self.sheet.row_values(0)) - 1
            i = 1
            for portName in self.sheet.row_values(0)[1:]:
                if portName:
                    self.portDictByIndex[i] = Port(portName, i)
                i = i + 1
        if self.sheet.row_values(1)[0] == "Function" and self.sheet.row_values(1)[1] == "Type":
            for i in range(2, self.sheet.nrows):
                if self.sheet.row_values(i)[0]:
                    self.funcDictByRow[i] = Func(self.sheet.row_values(i)[0], self.sheet.row_values(i)[1], i)

        for i in range(2, self.sheet.nrows):
            for j in range(2, self.sheet.ncols):
                if self.sheet.row_values(i)[j]:
                    self.crossCoList.append((i,j))

    def _writePortLine(self, f, portName, inOut, width=1, isReg=False, withComma=True, typeStartCol=10, widthStartCol=18, nameStartCol=28, cmtStartCol=48, cmt="", indentation=0):
        l = ""
        if portName:
            if inOut.lower() in ["i", "in", "input"]:
                l = l + "input "
                isReg = False
            else:
                l = l + "output "
        l = l + ' ' * (typeStartCol-len(l))
        if isReg:
            l = l + "reg "
        else:
            l = l + "wire "
        if width>1:
            l = l + ' ' * (widthStartCol-len(l)) + '[' + str(width-1) + ":0] "
        l = l + ' ' * (nameStartCol-len(l)) + portName
        if withComma:
            l = l + ','
        if cmt:
            l = l + ' ' * (cmtStartCol-len(l)) + "//" + cmt
        l = l + '\n'
        if indentation>0:
            l = ' '*indentation + l
        if width>0:
            f.write(l)

    def _writeRegWireLine(self, f, name, regWire, width=1, withSemiComma=True, widthStartCol=10, nameStartCol=20, cmtStartCol=48, cmt="", indentation=0):
        l = ""
        if regWire.lower() in ['r', 'reg']:
            l = l + "reg"
        elif regWire.lower() in ['w', 'wire']:
            l = l + "wire"
        l = l + ' '*(widthStartCol-len(l))
        if width>1:
            l = l + '[' + str(width-1) + ":0]"
        l = l + ' '*(nameStartCol-len(l))
        l = l + name
        if withSemiComma:
            l = l + ";"
        if cmt:
            l = l + ' '*(cmtStartCol-len(l)) + "//" + cmt
        if indentation>0:
            l = ' '*indentation + l
        l = l + '\n'
        if width>0:
            f.write(l)

    def writeVerilog(self, fileName, headCommentLength=66):
        f = open(fileName + ".v", 'w+')
        from datetime import datetime
        now = datetime.now()
        f.write("// " + '='*headCommentLength + '\n')
        f.write("// " + "This file is automatically generated.".center(headCommentLength) + "\n")
        f.write("// " + "Scripts by Cheng Cai".center(headCommentLength) + "\n")
        f.write("// " + "File name".ljust(int(headCommentLength/2)) + ":  " + fileName + "\n")
        f.write("// " + "Generation time".ljust(int(headCommentLength/2))  + ":  " + str(now.year) + '-' + str(now.month) + '-' + str(now.day) + " "
                + str(now.hour) + ":" + str(now.minute) + ":" + str(now.second) + "\n")
        f.write("// " + '='*headCommentLength + '\n')
        f.write("// Number of ports (with digital functions): " + str(len(self.portDictByIndex)) + "\n")
        f.write("// Number of digital functions: " + str(len(self.funcDictByRow)) + "\n"*2)

        f.write("module " + fileName + "(\n")
        #port list
        f.write("// Ports' data input and output\n")
        for p in self.portDictByIndex.values():
            portName = p.portName
            self._writePortLine(f=f, portName=portName+"_out", inOut="out", isReg=False)
            self._writePortLine(f=f, portName=portName+"_in", inOut="in", isReg=False)
        f.write("// Functions' input and/or output\n")
        for func in self.funcDictByRow.values():
            funcName = func.funcName
            if func.funcDir.lower() == "di":
                self._writePortLine(f=f, portName=funcName, inOut="out", isReg=False, cmt=funcName + " DI")
            elif func.funcDir.lower() == "do":
                self._writePortLine(f=f, portName=funcName, inOut="in", isReg=False, cmt=funcName + " DO")
            elif func.funcDir.lower() == "dio":
                self._writePortLine(f=f, portName=funcName + "_in", inOut="out", isReg=False, cmt=funcName+ " DIO")
                self._writePortLine(f=f, portName=funcName + "_out", inOut="in", isReg=False)
                self._writePortLine(f=f, portName=funcName + "_oe", inOut="in", isReg=False)
        f.write("// Ports' SKIP\n")
        for p in self.portDictByIndex.values():
            portSkip = p.portName + "_SKIP"
            self._writePortLine(f=f, portName=portSkip, inOut="in", isReg=False)
        f.write("// Functions' ON\n")
        funcOnList = []
        for func in self.funcDictByRow.values():
            funcOnList.append(func.funcName + "_ON")
        for funcOn in funcOnList[:-1]:
            self._writePortLine(f=f, portName=funcOn, inOut="in", isReg=False)
        self._writePortLine(f=f, portName=funcOnList[-1], inOut="in", isReg=False, withComma=False)
        f.write(");\n\n")

        #reg/wire var
        f.write("// func on pin\n")
        for co in self.crossCoList:
            row = co[0]
            col = co[1]
            funcOnPinName = self.funcDictByRow[row].funcName + "_on_" + self.portDictByIndex[col].portName
            self._writeRegWireLine(f=f, name=funcOnPinName, regWire="wire")
        f.write("// not skip\n")
        for p in self.portDictByIndex.values():
            portNotSkip = p.portName + "_not_SKIP"
            self._writeRegWireLine(f=f, name=portNotSkip, regWire="wire")


        f.write("\n"*2)
        #logic assignment
        for p in self.portDictByIndex.values(): 
            f.write("assign " + p.portName + "_not_SKIP = ~" + p.portName + "_SKIP;\n")
        
        f.close()
            




class Port(object):
    def __init__(self, portName, index):
        self.portName = portName
        self.index = index

class Func(object):
    def __init__(self, funcName, funcDir,row):
        self.funcName = funcName
        self.funcDir = funcDir
        self.row = row

if __name__ == "__main__":
    c = Crossbar("crossbar.xlsx", "crossbar")
    c.writeVerilog("crossbar")
